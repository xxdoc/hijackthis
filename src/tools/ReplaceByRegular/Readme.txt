=======================================
      ReplaceByRegular by Dragokas
=======================================

 - Скрипт для замены текста во множестве файлов согласно регулярным выражениям.

Состав:
Regular.txt - список замен
ReplaceByRegular.vbs - сам скрипт
Readme.txt - этот файл.

---------------------------
Описание для версии 1.9
---------------------------

Как пользоваться?

1)
Копируете файл Regular.txt и ReplaceByRegular.vbs
в папку, где нужно рекурсивно (с подкаталогами) провести замены текста.

Текст может быть в кодировках:
 - ANSI
 - UTF-8 (в этом случае текст регулярки также должен быть в UTF-8)
 - UTF-16 LE с BOM

2)
Откройте Regular.txt (должен лежать рядом со скриптом).
Создайте перечень замен вида:

word1=Что ищем1
word2=Чем заменяем1
word1=Что ищем2
word2=Чем заменяем2

где каждому word1= соостветствует word2=, который под ним находится.
Так, Вы можете сделать одновременно несколько разных замен.

word1= принимает для поиска регулярное выражение (писать после знака равенства).
word2= принимает текст, на который будет произведена замена части, найденной регуляркой, указанной в word1=

3) Запускаем скрипт ReplaceByRegular.vbs

Отчет о заменах будет создан в виде файла Replace - log.log рядом со скриптом.

--------------
  Настройки
--------------

1) Список расширений

Скрипт обрабатывает только файлы с расширениями, список которых указан в его шапке.
Правый клик по файлу ReplaceByRegular.vbs -> "Изменить"
Смотрим сюда (строка 5):

Dim Exts: Exts = "htm;html;txt"

2) Замена с учетом регистра букв.
Если Вы хотите отключить учет регистра при поиске по регулярному выражению:
Правый клик по файлу ReplaceByRegular.vbs -> "Изменить"
Смотрим сюда (строка 11):

Dim IgnoreCase: IgnoreCase = false

и меняем false на true


---------------
Примечания:
---------------

В word2 действуют некоторые правила экранирования. Так:

\\ будет заменен на \
\^ будет заменен на ^
\$ будет заменен на $
\* будет заменен на *
\+ будет заменен на +
\? будет заменен на ?
\. будет заменен на .
\| будет заменен на |
\n будет заменен на новую строку
\r будет заменен на перевод каретки
\t будет заменен на знак табуляции

Также есть 2 специальные замены:

1)

$$$file$$$ будет заменено на имя файла (+ расширение имени), в котором найдена искомая фраза.

Например, если файл назывался my.txt
а шаблоны такие:
word1=\<a href="default\.htm"\>
word2=<a href="$$$file$$$">

то
<a href="default.htm">
будет заменено на:
<a href="my.txt">

2)

\@{{{utf8toANSI}}}

означает, что искомая фраза будет перекодирована из кодировки utf-8 в ANSI,
где \@ - это подстановка искомой фразы.

Например, имеем текст в utf-8:
<title>Привет, regist</title>

После применения шаблона:
word1=<title>[^<]*</title>
word2="\@"{{{utf8toANSI}}}

Результат будет ANSI-строка (в кавычках):
"<title>Привет, regist</title>"

3)

\@{{{ANSItoUTF8}}}

означает, что искомая фраза будет перекодирована из кодировки ANSI в utf-8,
где \@ - это подстановка искомой фразы.

Например, имеем текст в ANSI:
<title>Привет, regist</title>

После применения шаблона:
word1=<title>[^<]*</title>
word2="\@"{{{ANSItoUTF8}}}

Результат будет UTF-8 строка (в кавычках):
"<title>Привет, regist</title>"

Обратите внимание, метка BOM автоматически не добавляется.
Некоторые редакторы могут неверно распознать исходный формат текстового файла.


P.S. "Я не люблю писать любые виды документации" (© Boban Spasic), но конкретно ЭТУ меня заставил написать regist и я ему это припомню :)
Вообщем, спасибо ему за разминку мозгов, по причине которой и родился этот скрипт.

------------
Checksum:

ReplaceByRegular.vbs
Digitally signed by Alex Dragokas (using self-signed certificate).

Certificate's thumbprint should be: 05F1F2D5BA84CDD6866B37AB342969515E3D912E
